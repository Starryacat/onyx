package builtin

//
// This file contains builtin operator overloads.
// It's in a separate file because we need to defer resolution of some definitions
// until certain types are defined (namely builtin code used for math operators).
//

//
// Allows for comparing `package_id`s
#operator == macro (p1, p2: package_id) => cast(u32) p1 == cast(u32) p2;
#operator != macro (p1, p2: package_id) => cast(u32) p1 != cast(u32) p2;

//
// Allows for basic array programming support

// Array w/ array operations
#operator + macro (l, r: [$N]$T) => __array_op_array(l, r, [a, b](a + b));
#operator - macro (l, r: [$N]$T) => __array_op_array(l, r, [a, b](a - b));
#operator * macro (l, r: [$N]$T) => __array_op_array(l, r, [a, b](a * b));
#operator / macro (l, r: [$N]$T) => __array_op_array(l, r, [a, b](a / b));

// Array w/ scalar operations
#operator + macro (l: [$N]$T, r: T) => __array_op_scalar(l, r, [a, b](a + b));
#operator - macro (l: [$N]$T, r: T) => __array_op_scalar(l, r, [a, b](a - b));
#operator * macro (l: [$N]$T, r: T) => __array_op_scalar(l, r, [a, b](a * b));
#operator / macro (l: [$N]$T, r: T) => __array_op_scalar(l, r, [a, b](a / b));

#operator == macro (l, r: [$N]$T) => memory_equal(cast(rawptr)l, cast(rawptr)r, N * sizeof T);
#operator != macro (l, r: [$N]$T) => !(l == r);

memory_equal :: (a: rawptr, b: rawptr, count: i32) -> bool #intrinsic --- // So we don't have to include core.intrinsics

__array_op_array :: macro (l, r: [$N]$T, $body: Code) -> [N]T {
    res: [N]T;
    for 0..N do res[it] = #unquote body(l[it], r[it]);
    return res;
}

__array_op_scalar :: macro (l: [$N]$T, r: T, $body: Code) -> [N]T {
    res: [N]T;
    for 0..N do res[it] = #unquote body(l[it], r);
    return res;
}



//
// Builtin for expansions
//

#overload
__for_expansion :: macro (r: range, $flags: i32, body: Code) {
    i    := r.low
    end  := r.high
    step := r.step
    
    while true {
        if step < 0  && i >= end do break
        if step >= 0 && i <  end do break
        
        defer i += step

        #unquote body(i) #skip_scope(2)
    }
}

#overload
__for_expansion :: macro (r: range64, $flags: i32, body: Code) {
    i    := r.low
    end  := r.high
    step := r.step
    
    while true {
        if step < 0  && i >= end do break
        if step >= 0 && i <  end do break
        
        defer i += step

        #unquote body(i) #skip_scope(2)
    }
}

#overload
__for_expansion :: macro (n: i32, flags: i32, body: Code) {
    i    := 0
    end  := n
    
    while i < end {
        defer i += step

        #unquote body(i) #skip_scope(2)
    }
}

#overload
__for_expansion :: macro (n: i64, flags: i32, body: Code) {
    i    : i64 = 0
    end  : i64 = n
    
    while i < end {
        defer i += step

        #unquote body(i) #skip_scope(2)
    }
}

#overload
__for_expansion :: macro (s: [] $T, $flags: i32, body: Code) where (flags & 1 == 0) {
    i := 0
    data  := s.data
    count := s.count

    while i < count {
        defer i += 1

        v := data[i]
        #unquote body(v, i) #skip_scope(2)
    }
}

#overload
__for_expansion :: macro (s: [] $T, $flags: i32, body: Code) where (flags & 1 != 0) {
    i := 0
    data  := s.data
    count := s.count

    while i < count {
        defer i += 1

        v := &data[i]
        #unquote body(v, i) #skip_scope(2)
    }
}


//
// Move these to iter.onyx
#overload
__for_expansion :: macro (iterator: Iterator($T), $flags: i32, $body: Code) where 
    (flags & 1 == 0) && (body.capture_count == 1)
{
    _iterator := iterator

    #if flags & 2 != 0 {
        defer _iterator.close(_iterator.data)
    }

    #if #defined(body.capture_type_2) {
        _i: body.capture_type_2
    } else {
        _i: i32
    }

    while true {
        defer _i += 1

        value := _iterator.next(_iterator.data)
        if value.tag == .None do break

        use core.memory
        _it := *cast(&T) memory.ptr_add(&value, alignof ? T)

        #unquote body(_it, _i) #skip_scope(2)
    }
}

#overload
__for_expansion :: macro (iterator: Iterator($T), $flags: i32, $body: Code) where 
    (flags & 1 != 0) && (body.capture_count == 1)
{
    _iterator := iterator

    #if (flags & 2 != 0) {
        defer _iterator.close(_iterator.data)
    }

    while true {
        value := _iterator.next(_iterator.data)
        if value.tag == .None do break

        use core.memory
        _it := *cast(&T) memory.ptr_add(&value, alignof ? T)

        #unquote body(_it) #skip_scope(2)
    }
}

